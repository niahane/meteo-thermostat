#Substitutions do un nome fisso a delle entita
substitutions:
#Set here your entities
  devicename: "display-28"
  ssid: Esp32-2432S028 Fallback Hotspot
  static_ip: 192.168.0.119
  gateway: 192.168.0.1
  subnet: 255.255.255.0
#Set here your entities
# Heater entity from home assistant, in my case i used a Shelly 1v3 for open/close contact of my house gas heater.
#You can also use a relay connected to a gpio but I do not recommend it especially if the load is alternating current the absorption peaks could glue the contacts of the cheap relays.
#I also noticed that the electromagnetic peak sometimes crashes the esp32. Since we are talking about a delicated system like a gas heater, it is better to opt for a certified device.
  heater: climate.cronotermostato
# Weather entity from home assistant
  weather_entity: weather.casa
# Total consumption sensor to import from home assistant i have a Shelly em with 2 amperomeric sensor, this is the first and grab the phase exiting from my energy grid
  tc: sensor.potenza_energia_elettrica_power
# Partial consumtion entity like washing machine etc to import from home assistant this is my second amperometric sensor and grab the phase of my garage
  pc: sensor.consumo_lavastoviglie_power
#Weather now icon size
  icon_xy: '65x65'
#temperatura purificatore config
  temperatura_purificatore : sensor.zhimi_airpurifier_mb3_temperature

globals:
  - id: menu_pos
    restore_value: no
    type: int
    initial_value: "0"
#definisco coordinate icona pagina succesiva
  - id: x_page
    type: int
    restore_value: no
    initial_value: '300'
  - id: y_page
    type: int
    restore_value: no
    initial_value: '220'




# display 320x240

esphome:
  name: $devicename
  friendly_name: Display 2.8

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "qFyyPu4U4WWJw9iV9+WlCO/aYmtA+DrovMJqmH2PHpg="
  services:
  # Receive sound from homeassistant as service (only buzzer rtttl)
    - service: play_rtttl
      variables:
        song_str: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return song_str;'

#Buzzer
rtttl:
  output: rtttl_out
ota:
  password: "b3c2948c5c1aa9c51f9e7b8e6ff9556a"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: $ssid
    password: "TuMHWpSUedAq"

captive_portal:
 #page successiva riferimenti definita come variabile globale


spi:
  - id: lcd
    clk_pin: GPIO14
    mosi_pin: GPIO13
    miso_pin: GPIO12
  - id: touch
    clk_pin: GPIO25
    mosi_pin: GPIO32
    miso_pin: GPIO39

i2c:
  sda: GPIO27
  scl: GPIO22
  scan: true
  id: bus_a


#This import arduinojson library for extract weather forecasts
json:

#Definisco imagini
#Weather now images
image:
#0-default.png
  - file: "images/0-default.png"
    id: wpng_0
    type: RGB24
    resize: ${icon_xy}
#1-clear-night.png
  - file: "images/1-clear-night.png"
    id: wpng_1
    type: RGB24
    resize: ${icon_xy}
#2-cloudy.png
  - file: "images/2-cloudy.png"
    id: wpng_2
    type: RGB24
    resize: ${icon_xy}
#3-fog.png
  - file: "images/3-fog.png"
    id: wpng_3
    type: RGB24
    resize: ${icon_xy}
#4-hail.png
  - file: "images/4-hail.png"
    id: wpng_4
    type: RGB24
    resize: ${icon_xy}
#5-lightning.png
  - file: "images/5-lightning.png"
    id: wpng_5
    type: RGB24
    resize: ${icon_xy}
#6-lightning-rainy.png
  - file: "images/6-lightning-rainy.png"
    id: wpng_6
    type: RGB24
    resize: ${icon_xy}
#7-partlycloudy.png
  - file: "images/7-partlycloudy.png"
    id: wpng_7
    type: RGB24
    resize: ${icon_xy}
#8-pouring.png // rgb565
  - file: "images/8-pouring.png"
    id: wpng_8
    type: RGB24
    resize: ${icon_xy}
#9-rainy.png
  - file: "images/9-rainy.png"
    id: wpng_9
    type: RGB24
    resize: ${icon_xy}
#10-snowy.png
  - file: "images/10-snowy.png"
    id: wpng_10
    type: RGB24
    resize: ${icon_xy}
#11-snowy-rainy.png
  - file: "images/11-snowy-rainy.png"
    id: wpng_11
    type: RGB24
    resize: ${icon_xy}
#12-sunny.png
  - file: "images/12-sunny.png"
    id: wpng_12
    type: RGB24
    resize: ${icon_xy}
#13-windy.png
  - file: "images/13-windy.png"
    id: wpng_13
    type: RGB24
    resize: ${icon_xy}
#14-windy-variant.png
  - file: "images/14-windy-variant.png"
    id: wpng_14
    type: RGB24
    resize: ${icon_xy}
#15-exceptional.png
  - file: "images/15-exceptional.png"
    id: wpng_15
    type: RGB24
    resize: ${icon_xy}
#16-radio e power
  - file: "images/power-off-button.png"
    id: on_off_button
  - file: "images/radio-station.png"
    id: radio

### CUSTOM!!
# menu spunto https://github.com/anton-semeniak/Esphome-TTGO-T-Display-Remote/blob/master/ttgo_menu.yaml


font:
  - file: "fonts/Helvetica.ttf"
    id: helvetica_48
    size: 48
  - file: "fonts/Helvetica.ttf"
    id: helvetica_36
    size: 36
  - file: "fonts/Helvetica.ttf"
    id: helvetica_24
    size: 24
  - file: "fonts/Helvetica.ttf"
    id: helvetica_12
    size: 12
  - file: "fonts/arial.ttf"
    id: font11
    size: 12
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_20
    size: 20
    glyphs: [
      "", # mdi-thermometer
      "", # mdi-water-percent
      "ﴟ", # mdi-air-filter
      "󰌶", # mdi-lightbulb-outline
      "󰛨", # mdi-lightbulb-on
       ] 


#Font declaration
#font date
  - file: 'fonts/arial-black.ttf'
    id: font1
    size: 16
#Time orologio dx
  - file: 'fonts/BebasNeue-Regular.ttf'
    id: font_clock
    size: 30
#Temperature blu  outside
  - file: 'fonts/BebasNeue-Regular.ttf'
    id: font2
    size: 35
#Location sensors
  - file: 'fonts/arial.ttf'
    id: font8
    size: 18
# Day name in forecast
  - file: 'fonts/arial-black.ttf'
    id: font_small
    size: 12
#Forecast fonts
  - file: 'fonts/arial.ttf'
    id: font_small_1
    size: 10
#Font icon various sensor
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: sensor_font
    size: 18
    glyphs:
      - "\U000F059D" # Wind
      - "\U000F050F" # Temperature
      - "\U000F04C5" # Pression
      - "\U000F058E" # Humidity
      - "\U000F0238" # Fire
      - "\U000F0F55" # Home thermometer
      - "\U000F0BB1" # next page               

#Big icons other home stuff
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: home_font
    size: 52
    glyphs:
      - "\U000F02DC" # At home
      - "\U000F0F9B" # Outside home
      - "\U000F0238" # Fire
      - "\U000F072A" # Washing machine on
      - "\U000F11BD" # Washing machine off
      - "\U000F0100" # Camera on
      - "\U000F05DF" # Camera off
      - "\U000F0241" # Flash
      - "\U000F0EF7" # Flash alert
      - "\U000F06D0" # Diocane
      - "\U000F0425" # OFF
      - "\U000F0415" # Plus
      - "\U000F0374" # Minus
      - "\U000F0335" # lightbulb pieno
      - "\U000F0336" # lightbulb vuoto

#Forecast icons
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: weather_font
    size: 50
    glyphs:
      - "\U000F0590" # weather-cloudy
      - "\U000F0F2F" # weather-cloudy-alert
      - "\U000F0E6E" # weather-cloudy-arrow-right
      - "\U000F0591" # weather-fog
      - "\U000F0592" # weather-hail
      - "\U000F0F30" # weather-hazy
      - "\U000F0898" # weather-hurricane
      - "\U000F0593" # weather-lightning
      - "\U000F067E" # weather-lightning-rainy
      - "\U000F0594" # weather-night
      - "\U000F0F31" # weather-night-partly-cloudy
      - "\U000F0595" # weather-partly-cloudy
      - "\U000F0F32" # weather-partly-lightning
      - "\U000F0F33" # weather-partly-rainy
      - "\U000F0F34" # weather-partly-snowy
      - "\U000F0F35" # weather-partly-snowy-rainy
      - "\U000F0596" # weather-pouring
      - "\U000F0597" # weather-rainy
      - "\U000F0598" # weather-snowy
      - "\U000F0F36" # weather-snowy-heavy
      - "\U000F067F" # weather-snowy-rainy
      - "\U000F0599" # weather-sunny
      - "\U000F0F37" # weather-sunny-alert
      - "\U000F14E4" # weather-sunny-off
      - "\U000F059A" # weather-sunset
      - "\U000F059B" # weather-sunset-down
      - "\U000F059C" # weather-sunset-up
      - "\U000F0F38" # weather-tornado
      - "\U000F059D" # weather-windy
      - "\U000F059E" # weather-windy-variant



color:
  - id: my_red
    red: 100%
    green: 0%
    blue: 0%
  - id: my_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: my_green
    red: 0%
    green: 100%
    blue: 0%
  - id: my_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: my_gray
    red: 50%
    green: 50%
    blue: 50%
  - id: my_orange
    red: 100%
    green: 50%
    blue: 0%
  - id: my_teal
    red: 0%
    green: 100%
    blue: 100%
  - id: my_white
    red: 100%
    green: 100%
    blue: 100%



#This create the climate entity
climate:
  - platform: thermostat
    visual:
      min_temperature: 16 °C
      max_temperature: 30 °C
    name: Termostato
    id: termostato1
    sensor: temp_int
    min_heating_off_time: 30s
    min_heating_run_time: 30s
    min_idle_time: 30s
    #This is the service to call on off of the Shelly 1v3 actuator.
    heat_action:
      homeassistant.service:
        service: switch.turn_on
        data: {entity_id: $heater}
    idle_action:
      homeassistant.service:
        service: switch.turn_off
        data: {entity_id: $heater}



# Pulsanti touchSCREEN

binary_sensor:
  - platform: status
    name: "Node Status"
    id: system_status

#Virtual touch buttons on display 320x240
#Touch key plus pagina avanti
  - platform: touchscreen
    id: touch_key_plus
    x_min: 260
    x_max: 320
    y_min: 180
    y_max: 240
    on_press:
      - display.page.show_next: schermo  
#Touch key meno
  - platform: touchscreen
    id: touch_key_minus
    x_min: 260
    x_max: 320
    y_min: 0
    y_max: 60
    on_press:
      - display.page.show_previous: schermo  
#Touch key climate on/off
  - platform: touchscreen
    id: touch_key_climate
    x_min: 260
    x_max: 320
    y_min: 100
    y_max: 160
    # page_id: page1
    on_click:
    #Thermostat on
    - min_length: 50ms
      max_length: 500ms
      then:
        - climate.control:
            id: termostato1
            mode: "HEAT"
        - rtttl.play: 'one short:d=4,o=5,b=100:16e6'
    #Thermostat off
    - min_length: 1000ms
      max_length: 5000ms
      then:
        - climate.control:
            id: termostato1
            mode: "OFF"
        - rtttl.play: 'one short:d=4,o=5,b=100:16e6'

#Touch key aumenta temperatura
  - platform: touchscreen
    id: touch_key_aumenta_temp
    x_min: 160
    x_max: 240
    y_min: 180
    y_max: 240
    page_id: page3
    on_press:
      - climate.control:
          id: termostato1
          target_temperature: !lambda return (id(termostato1).target_temperature + 0.5);
      - rtttl.play: 'one short:d=4,o=5,b=100:16e6'
#Touch key mdiminuisci temperatira
  - platform: touchscreen
    id: touch_key_diminuisce_temp
    x_min: 160
    x_max: 240
    y_min: 0
    y_max: 60
    page_id: page3
    on_press:
      - climate.control:
          id: termostato1
          target_temperature: !lambda return (id(termostato1).target_temperature - 0.5);
      - rtttl.play: 'one short:d=4,o=5,b=100:16e6'      








time:
  - platform: homeassistant
    id: esptime



sensor:
  - platform: uptime
    # name: Uptime Sensor
    internal: True
    id: uptime_sensor
    update_interval: 1s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                ("Uptime ") +
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();

  - platform: wifi_signal
    # name: "WiFi Signal Sensor"
    internal: True
    id: wifi_signal_sensor
    update_interval: 5s

#Import external temperature
  - platform: homeassistant
    id: weather_temperature
    entity_id: $weather_entity
    attribute: temperature
    internal: true
#Import Wind speed
  - platform: homeassistant
    id: vento
    entity_id: $weather_entity
    attribute: wind_speed
    internal: true
#Import Wind dir
  - platform: homeassistant
    id: wind_bearing
    entity_id: $weather_entity
    attribute: wind_bearing
    internal: true
#Import external Humidity
  - platform: homeassistant
    id: umidita_ext
    entity_id: $weather_entity
    attribute: humidity
    internal: true
#Import external pressure
  - platform: homeassistant
    id: pressure_ext
    entity_id: $weather_entity
    attribute: pressure
    internal: true

#Total energy in kw/h
  - platform: homeassistant
    id: consumo_t
    entity_id: $tc
    internal: true
#Lavastoviglie energy in kw/h
  - platform: homeassistant
    id: consumo_c
    entity_id: $pc
    internal: true



#Bme280 internal sensor su co2 BOX prendo tramite hA
  - platform: homeassistant
    id: temp_int
    entity_id: sensor.co2box_bmp280_temperature
    internal: true
  - platform: homeassistant
    id: pressione_int
    entity_id: sensor.co2box_bmp280_pressure
    internal: true
  - platform: homeassistant
    id: co2_int
    entity_id: sensor.co2box_mhz19b_carbondioxide
    internal: true
#temperatura umidita purificatore    
  - platform: homeassistant
    id: temperatura_pur
    entity_id: $temperatura_purificatore 
    internal: true
  - platform: homeassistant
    id: umidita_int
    entity_id: sensor.zhimi_airpurifier_mb3_humidity
    internal: true
#This import heater entity from home assistant (it is a shelly 1v3 that open or close the heater contact)
  - platform: homeassistant
    name: "Caldaia"
    entity_id: $heater
    id: sensor_caldaia
    internal: true


text_sensor:
  - platform: template
    # name: Uptime Human Readable
    id: uptime_human
    icon: mdi:clock-start
    internal: True

  - platform: wifi_info
    ip_address:
      # name: ESP IP Address
      id: ip_address
  # Sensore luci
  - platform: homeassistant
    id: luci
    entity_id: group.all_light
    name: "Luci Casa"
#Import Location
  - platform: homeassistant
    id: weather_location
    entity_id: $weather_entity
    attribute: friendly_name
    internal: true
#Import weather condition now
  - platform: homeassistant
    id: weather_condition
    entity_id: $weather_entity
    internal: true
#Import 5 day forecast
  - platform: homeassistant
    id: forecast_5
    entity_id: $weather_entity
    attribute: forecast
    internal: yes
#Import Sun state
  - platform: homeassistant
    id: sun_state
    entity_id: sun.sun
    internal: true

#imposto grafico pagina 4
graph:
  # Show multi-trace graph
  - id: multi_temperature_graph
    duration: 1h
    x_grid: 10min
    y_grid: 1.0     # degC/div
    width: 200
    height: 80
    max_value: 40

    traces:
      - sensor: temperatura_pur
        line_type: DASHED
        line_thickness: 2
        color: my_red
      - sensor: weather_temperature
        line_type: SOLID
        line_thickness: 3
        color: my_blue

display:
  - platform: ili9xxx
    model: ILI9341
    spi_id: lcd
    cs_pin: 15
    dc_pin: 2
    rotation: 90
    id: schermo
    pages:


# https://github.com/niahane/meteo-thermostat
    - id: page1    # pagina 1
      lambda: |-
         //Map icons//
         std::map<std::string, image::Image *> imgDict;
         imgDict["clear-night"] = id(wpng_1);
         imgDict["cloudy"] = id(wpng_2);
         imgDict["fog"] = id(wpng_3);
         imgDict["hail"] = id(wpng_4);
         imgDict["lightning"] = id(wpng_5);
         imgDict["lightning-rainy"] = id(wpng_6);
         imgDict["partlycloudy"] = id(wpng_7);
         imgDict["pouring"] = id(wpng_8);
         imgDict["rainy"] = id(wpng_9);
         imgDict["snowy"] = id(wpng_10);
         imgDict["snowy-rainy"] = id(wpng_11);
         imgDict["sunny"] = id(wpng_12);
         imgDict["windy"] = id(wpng_13);
         imgDict["windy-variant"] = id(wpng_14);
         imgDict["exceptional"] = id(wpng_15);
         imgDict[""] = id(wpng_0);
         
         //Map conditions//
         std::map<std::string, const char *> conDict;
         conDict["clear-night"] = "Notte serena";
         conDict["cloudy"] = "Nuvoloso";
         conDict["fog"] = "Nebbia";
         conDict["hail"] = "Nevischio";
         conDict["lightning"] = "Fulmini";
         conDict["lightning-rainy"] = "Fulmini/pioggia";
         conDict["partlycloudy"] = "Parz. Nuv.";
         conDict["pouring"] = "Rovescio";
         conDict["rainy"] = "Pioggia";
         conDict["snowy"] = "Neve";
         conDict["snowy-rainy"] = "Neve/pioggia";
         conDict["sunny"] = "Sereno";
         conDict["windy"] = "Vento";
         conDict["windy-variant"] = "Vento forte";
         conDict["exceptional"] = "Eccezionale";
         conDict[""] = "Sconosciuto";
         
         //Map weather fonts//
         std::map<std::string, const char *> fonDict;
         fonDict["clear-night"] = "\U000F0594";
         fonDict["cloudy"] = "\U000F0590";
         fonDict["fog"] = "\U000F0591";
         fonDict["hail"] = "\U000F0592";
         fonDict["lightning"] = "\U000F0593";
         fonDict["lightning-rainy"] = "\U000F067E";
         fonDict["partlycloudy"] = "\U000F0595";
         fonDict["pouring"] = "\U000F0596";
         fonDict["rainy"] = "\U000F0597";
         fonDict["snowy"] = "\U000F0598";
         fonDict["snowy-rainy"] = "\U000F067F";
         fonDict["sunny"] = "\U000F0599";
         fonDict["windy"] = "\U000F059D";
         fonDict["windy-variant"] = "\U000F059E";
         fonDict["exceptional"] = "";
         
         //Map days of week//
         std::map<int, const char *> dayDict;
         dayDict[1] = "Dom";
         dayDict[2] = "Lun";
         dayDict[3] = "Mar";
         dayDict[4] = "Mer";
         dayDict[5] = "Gio";
         dayDict[6] = "Ven";
         dayDict[7] = "Sab";
         
         //Map days of week extended//
         std::map<int, const char *> dayDict_ext;
         dayDict_ext[1] = "Domenica";
         dayDict_ext[2] = "Lunedi";
         dayDict_ext[3] = "Martedi";
         dayDict_ext[4] = "Mercoledi";
         dayDict_ext[5] = "Giovedi";
         dayDict_ext[6] = "Venerdi";
         dayDict_ext[7] = "Sabato";
         
         //Map month//
         std::map<int, const char *> monDict;
         monDict[1] = "Gennaio";
         monDict[2] = "Febbraio";
         monDict[3] = "Marzo";
         monDict[4] = "Aprile";
         monDict[5] = "Maggio";
         monDict[6] = "Giugno";
         monDict[7] = "Luglio";
         monDict[8] = "Agosto";
         monDict[9] = "Settembre";
         monDict[10] = "Ottobre";
         monDict[11] = "Novembre";
         monDict[12] = "Dicembre";
         
         //Today weekday as number
         int day = id(esptime).now().day_of_week;
         //Month as number
         auto month = id(esptime).now().month;
         //Day of month as number
         auto dom = id(esptime).now().day_of_month;
         
         //Position Y 1 day of week, day of month, month
         int h1 = 0;
         //Position Y 2 time
         int h2 = 5;
         //Position Y 3 weather icons, location, home name
         int h3 = 18;
         //Position Y 4 temperature ext, int, 
         int h4 = 30;
         //Position Y 6 humidity ext, int
         int h6 = 50;
         //Position Y 7 wind, Pressure int
         int h7 = 65;
         //Position Y wy forecast
         int wy = 85;
         //Position X wx forecast
         int wx = 32;
         //Position X 1 Weather location name, outside temp
         int w1 = 70;
         //Position Y 2 Outside sensor icon
         int w2 = 115;  
         //Position X 3 Home name, home temperature
         int w3 = 200;
         //Position X 4 Home sensor icon
         int w4 = 250;
         
         //Begin print to screen
         // Time
         it.printf((it.get_width() / 2), h1, id(font1), id(my_gray), TextAlign::TOP_CENTER, "%s %i %s", dayDict[day], dom, monDict[month]);
         it.strftime(it.get_width(), h2, id(font_clock), TextAlign::TOP_RIGHT, "%H:%M", id(esptime).now());

         // Weather now if it's night and sunny for display night icon
         if (id(sun_state).state == "below_horizon" && id(weather_condition).state == "sunny") {
            // Icon of weather condition night
            it.image(0, h3, imgDict["clear-night"]);
            // Translated weather condition state as text
            it.printf(0, h1, id(font_small), id(my_gray), "%s", conDict["clear-night"]);
         } else {
            // Check if weather_condition has a known state in the dictionary to prevent a crash
            if (conDict.count(id(weather_condition).state) > 0) {
               // Weather now for other cases
               // Icon of weather condition now
               it.image(0, h3, imgDict[id(weather_condition).state]);
               // Translated weather condition state as text
               it.printf(0, h1, id(font_small), id(my_gray), "%s", conDict[id(weather_condition).state]);
            } else {
               // This is printed in case weather_condition has another or unknown state
               it.image(0, h3, imgDict["exceptional"]);
               // Translated weather condition state as text
               it.printf(0, h1, id(font_small), id(my_gray), "%s", conDict["exceptional"]);
            }
         }

         // Outside temp
         if (id(weather_temperature).has_state()) {
            it.printf(w1, h4, id(font2), id(my_blue), "%.0f°", id(weather_temperature).state);
         }

         // Location
         if (id(weather_location).has_state()) {
            it.printf(w1, h3, id(font8), id(my_blue), "%s", id(weather_location).state.c_str());
         }

         // Inside temp
         if (id(temp_int).has_state()) {
            it.printf(w3, h3, id(font8), id(my_red), "Casa");
            it.printf(w3, h4, id(font2), id(my_red), "%.0f°", id(temp_int).state);
         }

         // Today wind
         if (id(vento).has_state()) {
            it.printf(w2, h7, id(sensor_font), "\U000F059D");
            it.printf(w2 + 20, h7, id(font8), id(my_gray), "%.0f km/h", id(vento).state);
         }

         // External humidity
         if (id(umidita_ext).has_state()) {
            it.printf(w2, h6, id(sensor_font), "\U000F058E");
            it.printf(w2 + 20, h6, id(font8), id(my_gray), "%.0f%%", id(umidita_ext).state);
         }

         // Internal humidity
         if (id(umidita_int).has_state()) {
            it.printf(w4, h6, id(sensor_font), "\U000F058E");
            it.printf(it.get_width(), h6, id(font8), id(my_gray), TextAlign::TOP_RIGHT, "%.0f%%", id(umidita_int).state);
         }

         // Atmospheric pressure
         if (id(pressione_int).has_state()) {
            it.printf(w4, h7, id(sensor_font), "\U000F04C5");
            it.printf(it.get_width(), h7, id(font8), id(my_gray), TextAlign::TOP_RIGHT, "%.0fb", id(pressione_int).state);
         }

         // Imported forecast json deserialization
         if (id(forecast_5).has_state()) {
            int wxx = 0;
            int wyy = 0;
            int forday = 1;
            DynamicJsonDocument doc(2048);
            deserializeJson(doc, (id(forecast_5).state.c_str()));
            JsonArray root = doc.as<JsonArray>();
            for (int i = 0; i <= 3; ++i) {
               JsonObject root_x = root[i];
               if (i == 0) {
                     wxx = wx;
                     wyy = wy;
                     forday = (id(esptime).now().day_of_week + 1);
               }
               if (forday == 8) {
                     forday = 1;
               }
               // Day 3-4 go down
               // if (i == 2) {wyy += 38;}
               // if (i == 2) {wxx = 0;}
               std::string root_0_condition = root_x["condition"];
               float root_0_precipitation = root_x["precipitation"];
               float root_0_temperature = root_x["temperature"];
               float root_0_templow = root_x["templow"];

               // Print to screen
               // Translated day
               it.printf(wxx, wyy, id(font_small), id(my_green), TextAlign::TOP_CENTER, "%s", dayDict_ext[forday]);
               // Icon condition
               if (fonDict.count(root_0_condition) > 0) {
                     it.printf(wxx, wyy + 12, id(weather_font), TextAlign::TOP_CENTER, "%s", fonDict[root_0_condition.c_str()]);
               }
               // Temp max
               it.printf(wxx, wyy + 60, id(font_small_1), TextAlign::TOP_CENTER, "max %.0f°", root_0_temperature);
               // Temp min
               it.printf(wxx, wyy + 70, id(font_small_1), TextAlign::TOP_CENTER, "min %.0f°", root_0_templow);
               // Rain in mm
               it.printf(wxx, wyy + 80, id(font_small_1), TextAlign::TOP_CENTER, "%.0f mm", root_0_precipitation);
               // lines
               it.line(0, wy, it.get_width(), wy);
               it.line(0, wy + 95, it.get_width(), wy + 95);
               wxx += 85;
               forday += 1;
            }
         }
         // Heater icon
         if ((id(termostato1).mode) == 0) {
            it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0425");
          } else {
            if (id(sensor_caldaia).state) {
               it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_red), TextAlign::BASELINE_CENTER, "\U000F0238");
            } else {
               it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0238");
            }
         }

         // Display thermostat desired temperature
          it.printf((it.get_width() / 2), it.get_height(), id(font8), id(my_red), TextAlign::BASELINE_CENTER, "%.1f°", id(termostato1).target_temperature);

         // When the motion sensor sees something, draw 2 eyes
         // if (id(movimento).state) {
         //   it.printf(it.get_width(), it.get_height(), id(home_font), id(my_red), TextAlign::BASELINE_RIGHT, "\U000F06D0");
         //   it.printf(0, it.get_height(), id(home_font), id(my_red), TextAlign::BASELINE_LEFT, "\U000F06D0");
         // } else {
            // Plus Key
            it.printf(it.get_width(), it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_RIGHT, "\U000F0415");
            // Minus key
            it.printf(0, it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_LEFT, "\U000F0374");
         // }

         // Total absorption icon and value
         if (id(consumo_t).has_state()) {
            if (id(consumo_t).state < 2800) {
               it.printf((it.get_width() / 2 - 65), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0241");
               it.printf((it.get_width() / 2 - 65), it.get_height(), id(font8), id(my_blue), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_t).state);
            } else {
               it.printf((it.get_width() / 2 - 65), (it.get_height() - 15), id(home_font), id(my_red), TextAlign::BASELINE_CENTER, "\U000F0241");
               it.printf((it.get_width() / 2 - 65), it.get_height(), id(font8), id(my_red), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_t).state);
            }
         }

         // Washing machine status and absorption value
         if (id(consumo_c).has_state()) {
            if (id(consumo_c).state > 20) {
               it.printf((it.get_width() / 2 + 65), (it.get_height() - 15), id(home_font), id(my_red), TextAlign::BASELINE_CENTER, "\U000F072A");
               it.printf((it.get_width() / 2 + 65), it.get_height(), id(font8), id(my_red), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_c).state);
            } else {
               it.printf((it.get_width() / 2 + 65), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F11BD");
               it.printf((it.get_width() / 2 + 65), it.get_height(), id(font8), id(my_blue), TextAlign::BASELINE_CENTER, "%.0f W", id(consumo_c).state);
            }
         }



    - id: page2   # pagina 2
      lambda: |-

          // cordinate scritta direzione  vento
          int DIRx = 110;
          int DIRy = 50;
          // cordinate centro rosa venti
          int cerchio_x = 120;
          int cerchio_y = 70;
          int raggio = 50;


          // Convert wind direction da int a float con nome DIR per fare IF
          float dir = id(wind_bearing).state;

          // Wind DIREZIONE NANE (do il nome)
          
            std::string  name_dir;  // definisco variabile locale stringa di nome name_dir dove assegno la direzione del vento in NSEW
            std::string  name_vento;  // definisco variabile locale stringa di nome vento

            if (dir>0 && dir<=11) { name_dir = "N"; name_vento = "Tramontana"; }
             else {
            if (dir>11 && dir<=33) { name_dir = "NEE"; name_vento = "Tramontana"; } 
             else {
            if (dir>33 && dir<=55) { name_dir = "NE"; name_vento = "Greco"; } 
             else {
            if (dir>55 && dir<=77) { name_dir = "ENE"; name_vento = "Greco"; } 
             else {
            if (dir>77 && dir<=99) { name_dir = "E"; name_vento = "Levante"; } 
             else {
            if (dir>99 && dir<=121) { name_dir = "ESE"; name_vento = "Levante"; } 
             else {
            if (dir>121 && dir<=143) { name_dir = "SE"; name_vento = "Scirocco"; } 
             else { 
            if (dir>143 && dir<=165) { name_dir = "SSE"; name_vento = "Scirocco"; } 
             else { 
            if (dir>165 && dir<=190) { name_dir = "S"; name_vento = "Mezzogiorno"; } 
             else {   
            if (dir>190 && dir<=212) { name_dir = "SSW"; name_vento = "Mezzogiorno"; } 
             else {   
            if (dir>212 && dir<=234) { name_dir = "SW"; name_vento = "Libeccio"; } 
             else {   
            if (dir>234 && dir<=256) { name_dir = "WSW"; name_vento = "Libeccio"; } 
             else {   
            if (dir>256 && dir<=278) { name_dir = "W"; name_vento = "Ponente"; } 
             else {   
            if (dir>278 && dir<=300) { name_dir = "WNW"; name_vento = "Ponente"; } 
             else {   
            if (dir>300 && dir<=322) { name_dir = "NW"; name_vento = "Maestrale"; } 
             else {   
            if (dir>322 && dir<=344) { name_dir = "NNW"; name_vento = "Maestrale"; } 
             else {   
            if (dir>344 && dir<=360) { name_dir = "N"; name_vento = "Tramontana"; } 
             else {                   
           } } } } } } } } } } } } } } } } }


 
          // Colours - used for visiual indication of wind strength
          auto red = Color(255, 0, 0);
          auto green = Color(0, 255, 0);
          auto light_blue = Color(135, 237, 232);
          auto orange = Color(255, 170, 43);
          auto white = Color(255, 255, 255);
          auto purple = Color(97, 15, 219);
          auto grey = Color(100, 135, 135);

          // history arrays for trend display
          static float hist_wind[30];
          static int hist_dir[30];
          static int index=0;
          static int prev_index=29;




          // Store in array
          if ((hist_wind[prev_index]!=id(vento).state || hist_dir[prev_index]!=dir) && id(vento).state!=0) {
            hist_wind[index] = id(vento).state;
            hist_dir[index] = dir;
            index += 1;
            prev_index += 1;
            if (index==30) { index = 0; }
            if (prev_index==30) { prev_index = 0; }
          }
          // Trend maximum for last 30
          float max = hist_wind[0];
          for (size_t i = 0; i < 30; ++i) {
            if (hist_wind[i] > max) {
              max = hist_wind[i];
            }
          }

          // Weather data
          
          //it.strftime(5, 20, idfont11), TextAlign::TOP_LEFT, "%H:%M", id(esptime).now());
         
          it.printf(50, 20, id(font11), TextAlign::TOP_RIGHT, "%.1f°C", id(weather_temperature).state);
          it.printf(230, 20, id(font11), TextAlign::TOP_RIGHT, "%.1f hPa", id(pressure_ext).state);

          // it.printf(55, 20, id(font11), TextAlign::BOTTOM_RIGHT, "%s mm", conDict[id(weather_condition).state]);

          // Wind details
          it.printf(DIRx, DIRy, id(font8), id(my_blue), "%s", name_dir.c_str());
          it.printf(100, 95, id(font11), TextAlign::BOTTOM_LEFT, "%.1f km/h", id(vento).state);
          it.printf(100, 80, id(font11), TextAlign::BOTTOM_LEFT, "%.1f°", id(wind_bearing).state);
          it.printf(230, 120, id(font11), TextAlign::TOP_RIGHT, "TM %2.1f km/h", max);
          it.printf(50, 120, id(font11), TextAlign::TOP_RIGHT, "%s", name_vento.c_str());


      

          // Display trend data linea direzione vento
          for (size_t i = 0; i < 30; ++i) {
            if (hist_wind[i]>0) {
              int a = cerchio_x + ((90-(70*hist_wind[i]/max)) * (cos((hist_dir[i]-90)*PI/180)));
              int b = cerchio_y + ((90-(70*hist_wind[i]/max)) * (sin((hist_dir[i]-90)*PI/180)));
              int c = cerchio_x + (raggio * (cos((hist_dir[i]-90)*PI/180)));
              int d = cerchio_y + (raggio * (sin((hist_dir[i]-90)*PI/180)));
              it.line(a, b, c, d, grey);
            }
          }



          // Compass rose
          it.circle(cerchio_x, cerchio_y, raggio); //raggio 50
          it.print(cerchio_x, 20, id(font11), red, TextAlign::BOTTOM_CENTER, "N");
          it.print(cerchio_x, 120, id(font11), red, TextAlign::TOP_CENTER, "S");
          it.print(60, cerchio_y, id(font11), red, TextAlign::CENTER_RIGHT, "W");
          it.print(180, cerchio_y, id(font11), red, TextAlign::CENTER_LEFT, "E");


          // Calculate xy position to plot wind indicator
          int x = cerchio_x + (raggio * (cos((dir-90)*PI/180)));
          int y = cerchio_y + (raggio * (sin((dir-90)*PI/180)));

          // Wind pointerpuntatore colorato velocita
          if (id(vento).state<=11) { it.filled_circle(x, y, 7, light_blue); }
            else {
          if (id(vento).state>11 && id(vento).state<=30) { it.filled_circle(x, y, 7, green); } 
            else {
          if (id(vento).state>30 && id(vento).state<=60) { it.filled_circle(x, y, 7, orange); } 
            else {
          if (id(vento).state>60) { it.filled_circle(x, y, 7, red); } 
            } } }


          // PARTE COMUNE IN FONDO DEI PULSANTI TOUCH
          // Heater icon
          if ((id(termostato1).mode) == 0) {
             it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0425");
           } else {
             if (id(sensor_caldaia).state) {
                it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_red), TextAlign::BASELINE_CENTER, "\U000F0238");
             } else {
                it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0238");
             }
          }
          // Display thermostat desired temperature
           it.printf((it.get_width() / 2), it.get_height(), id(font8), id(my_red), TextAlign::BASELINE_CENTER, "%.1f°", id(termostato1).target_temperature);

            // Plus Key
            it.printf(it.get_width(), it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_RIGHT, "\U000F0415");
            // Minus key
            it.printf(0, it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_LEFT, "\U000F0374");
          // PARTE COMUNE IN FONDO DEI PULSANTI TOUCH

    - id: page3    # pagina 3
      lambda: |-

          // Draw the graph at position [x=10,y=20]
          it.graph(30, 40, id(multi_temperature_graph), my_gray);
          it.printf(20, 10, id(font8), id(my_red), TextAlign::TOP_LEFT, "Casa: %.0f°C", id(temperatura_pur).state);
          it.printf(120, 10, id(font8), id(my_blue), TextAlign::TOP_LEFT, "Esterno: %.0f°C", id(weather_temperature).state);
          // simbolo + per aumenta temperatura
          it.printf(it.get_width(), (it.get_height() - 50), id(home_font), id(my_gray), TextAlign::BASELINE_RIGHT, "\U000F0415");
          // simbolo meno per diminuisci temperatura
          it.printf(0, (it.get_height() - 50), id(home_font), id(my_gray), TextAlign::BASELINE_LEFT, "\U000F0374");

          // PARTE COMUNE IN FONDO DEI PULSANTI TOUCH
          // Heater icon
          if ((id(termostato1).mode) == 0) {
             it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0425");
           } else {
             if (id(sensor_caldaia).state) {
                it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_red), TextAlign::BASELINE_CENTER, "\U000F0238");
             } else {
                it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0238");
             }
          }
          // Display thermostat desired temperature
           it.printf((it.get_width() / 2), it.get_height(), id(font8), id(my_red), TextAlign::BASELINE_CENTER, "%.1f°", id(termostato1).target_temperature);

            // Plus Key
            it.printf(it.get_width(), it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_RIGHT, "\U000F0415");
            // Minus key
            it.printf(0, it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_LEFT, "\U000F0374");
          // PARTE COMUNE IN FONDO DEI PULSANTI TOUCH


    - id: page4    # pagina 4 
      lambda: |-
        int hs = it.get_width() / 2; // Horizontal Spacing = text data horizontal center point
        int hq = it.get_width() / 4; // text data horizontal center for two vertical lines
        int vs = it.get_height() / 8; // Vertical Center = text data vertical center point = how many lines
        int line_gap = 21; // distance of line from center of data text
        it.rectangle(0,  0, it.get_width(), it.get_height(), id(my_blue));
         it.rectangle(0, 20, it.get_width(), it.get_height(), id(my_blue));
      
        it.strftime(5, 5, id(helvetica_12), id(my_white), TextAlign::TOP_LEFT, "%H:%M:%S", id(esptime).now());
        it.print(hs, 5, id(helvetica_12), id(my_blue), TextAlign::TOP_CENTER, "${devicename}"); //print title  
      
        if (id(system_status).state) {
          it.print(it.get_width()-5, 5, id(helvetica_12), id(my_green), TextAlign::TOP_RIGHT, "Online");
        }
        else {
          it.print(it.get_width()-5, 5, id(helvetica_12), id(my_red), TextAlign::TOP_RIGHT, "Offline");
        }
        it.line(0, it.get_height()-60, it.get_width(), it.get_height()-60, id(my_blue)); // line orizzontale bottom above footer text
        it.printf(5, it.get_height()-63, id(helvetica_12), id(my_gray), TextAlign::BOTTOM_LEFT, "%s", id(uptime_human).state.c_str());
        it.printf(hs, it.get_height()-63, id(helvetica_12), id(my_gray), TextAlign::BOTTOM_CENTER, "%.0fdBm", id(wifi_signal_sensor).state);
        it.printf(it.get_width()-5, it.get_height()-63, id(helvetica_12), id(my_gray), TextAlign::BOTTOM_RIGHT, "%s", id(ip_address).state.c_str());


        it.line(0, vs * 3, it.get_width(), vs * 3, id(my_blue));
        it.line(0, vs * 4, it.get_width(), vs * 4, id(my_blue));


        // prova luci
        it.print(4, 25, id(font11), "Entita:");
        it.printf(4, 40, id(font11), id(my_yellow), "Luci: %s", id(luci).state.c_str());
        it.printf(4, 55, id(font11), id(my_yellow), "Consumo: %.0f Watt", id(consumo_t).state);
        it.print(4, 75, id(icon_font_20), "󰛨");


          // PARTE COMUNE IN FONDO DEI PULSANTI TOUCH
          // Heater icon
          if ((id(termostato1).mode) == 0) {
             it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0425");
           } else {
             if (id(sensor_caldaia).state) {
                it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_red), TextAlign::BASELINE_CENTER, "\U000F0238");
             } else {
                it.printf((it.get_width() / 2), (it.get_height() - 15), id(home_font), id(my_gray), TextAlign::BASELINE_CENTER, "\U000F0238");
             }
          }
          // Display thermostat desired temperature
           it.printf((it.get_width() / 2), it.get_height(), id(font8), id(my_red), TextAlign::BASELINE_CENTER, "%.1f°", id(termostato1).target_temperature);

            // Plus Key
            it.printf(it.get_width(), it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_RIGHT, "\U000F0415");
            // Minus key
            it.printf(0, it.get_height(), id(home_font), id(my_gray), TextAlign::BASELINE_LEFT, "\U000F0374");
          // PARTE COMUNE IN FONDO DEI PULSANTI TOUCH








# Define pins for backlight display and back LED1
output:
  - platform: ledc
    pin: GPIO21
    id: former_led_pin
  - platform: ledc
    id: output_red
    pin: GPIO4
    inverted: true
  - platform: ledc
    id: output_green
    pin: GPIO16
    inverted: true
  - platform: ledc
    id: output_blue
    pin: GPIO17
    inverted: true
  # speaker P4
  - platform: ledc
    pin: GPIO26
    id: rtttl_out

# Define a monochromatic, dimmable light for the backlight
light:
  - platform: monochromatic
    output: former_led_pin
    name: "Display Backlight"
    id: back_light
    restore_mode: ALWAYS_ON
  - platform: rgb
    name: LED
    red: output_red
    id: led
    green: output_green
    blue: output_blue
    restore_mode: ALWAYS_OFF

touchscreen:
  platform: xpt2046
  spi_id: touch
  cs_pin: 33
  interrupt_pin: 36
  update_interval: 50ms
  # report_interval: 1s
  threshold: 400
  calibration_x_min: 273
  calibration_x_max: 3771
  calibration_y_min: 192
  calibration_y_max: 3631
  on_touch:
    - script.stop: backlight_timer
    - script.execute: backlight_timer
  #Uncomment for calibrations
  #  - lambda: |-
  #        ESP_LOGI("cal", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
  #            touch.x,
  #            touch.y,
  #            touch.x_raw,
  #            touch.y_raw
  #            );
  #Uncomment for calibrations

#This is the script for turn off the backlight after some seconds of inactivity
script:
  id: backlight_timer
  then:
  - light.turn_on:
      id: back_light
      brightness: 100%
  - delay: 20s
  - light.turn_on:
      id: back_light
      brightness: 50%
  - delay: 40s
  - light.turn_off: back_light

# Exposed switches.
switch:
  - platform: restart
    name: ESP32-2432S028 Restart
